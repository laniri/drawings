# GitHub Actions Workflow for Children's Drawing Anomaly Detection System
# This workflow handles CI/CD for the AWS production deployment

name: Deploy to AWS Production

# Workflow-level permissions
permissions:
  contents: read
  security-events: write
  actions: read
  id-token: write

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_infrastructure:
        description: 'Deploy infrastructure changes'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: eu-west-1
  ECR_REPOSITORY: children-drawing-anomaly-detection
  ECS_CLUSTER: children-drawing-prod-cluster
  ECS_SERVICE: children-drawing-prod-service
  CONTAINER_NAME: app

jobs:
  # ============================================================================
  # Test Job - Run on all PRs and pushes
  # ============================================================================
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Free up disk space
      run: |
        # Show initial disk usage
        echo "=== Initial Disk Usage ==="
        df -h
        
        # Remove unnecessary packages to free up space (ignore errors for missing packages)
        echo "=== Removing unnecessary packages ==="
        sudo apt-get remove -y --ignore-missing \
          '^dotnet-.*' \
          '^llvm-.*' \
          'php.*' \
          '^mongodb-.*' \
          azure-cli \
          google-cloud-cli \
          google-chrome-stable \
          firefox \
          powershell \
          mono-devel \
          libgl1-mesa-dri || true
        
        # Clean up package cache
        sudo apt-get autoremove -y
        sudo apt-get autoclean
        
        # Remove some large directories if they exist
        sudo rm -rf /usr/share/dotnet || true
        sudo rm -rf /usr/local/lib/android || true
        sudo rm -rf /opt/ghc || true
        sudo rm -rf /opt/hostedtoolcache/CodeQL || true
        
        # Show final disk usage
        echo "=== Final Disk Usage ==="
        df -h
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        # Use lighter CI requirements instead of full dev requirements
        pip install -r requirements-ci.txt
    
    - name: Run linting
      env:
        PYTHONPATH: .
      run: |
        flake8 app/
        black --check app/
        isort --check-only app/
    
    - name: Run type checking
      env:
        PYTHONPATH: .
      run: |
        mypy app/
    
    - name: Run unit tests
      env:
        # Skip heavy model loading in CI
        SKIP_MODEL_LOADING: "true"
        # Use in-memory database for faster tests
        DATABASE_URL: "sqlite:///:memory:"
        # Add current directory to Python path
        PYTHONPATH: .
      run: |
        pytest tests/ -v --cov=app --cov-report=xml -x --tb=short
    
    - name: Run property-based tests
      run: |
        pytest tests/test_property_*.py -v --tb=short
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          coverage.xml
          pytest-report.xml

  # ============================================================================
  # Security Scan Job
  # ============================================================================
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    # Required permissions for security scanning
    permissions:
      contents: read
      security-events: write
      actions: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v4
      if: always()
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'
    
    - name: Run dependency check
      run: |
        pip install safety
        safety check --json --output safety-report.json || true
    
    - name: Upload security scan artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          trivy-results.sarif
          safety-report.json
    
    - name: Security scan summary
      if: always()
      run: |
        echo "## Security Scan Results" >> $GITHUB_STEP_SUMMARY
        echo "- Trivy filesystem scan: Completed" >> $GITHUB_STEP_SUMMARY
        echo "- Safety dependency check: Completed" >> $GITHUB_STEP_SUMMARY
        echo "- Results uploaded as artifacts" >> $GITHUB_STEP_SUMMARY
        if [ -f "trivy-results.sarif" ]; then
          echo "- SARIF upload: Attempted (may require GitHub Advanced Security)" >> $GITHUB_STEP_SUMMARY
        fi

  # ============================================================================
  # Build and Push Docker Image
  # ============================================================================
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test]  # Removed security-scan dependency
    if: github.ref == 'refs/heads/main'
    
    # Required for OIDC
    permissions:
      id-token: write
      contents: read
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-BuildPush-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build Docker image with build cache
        docker build -f Dockerfile.prod \
          --cache-from $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Push image to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
    
    - name: Scan Docker image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ steps.build-image.outputs.image }}
        format: 'sarif'
        output: 'docker-trivy-results.sarif'
    
    - name: Upload Docker scan results
      uses: github/codeql-action/upload-sarif@v4
      if: always()
      continue-on-error: true
      with:
        sarif_file: 'docker-trivy-results.sarif'
    
    - name: Docker security scan summary
      if: always()
      run: |
        echo "## Docker Security Scan" >> $GITHUB_STEP_SUMMARY
        echo "- Image vulnerability scan: Completed" >> $GITHUB_STEP_SUMMARY
        echo "- Image: ${{ steps.build-image.outputs.image }}" >> $GITHUB_STEP_SUMMARY
        if [ -f "docker-trivy-results.sarif" ]; then
          echo "- SARIF results: Generated" >> $GITHUB_STEP_SUMMARY
        fi

  # ============================================================================
  # Deploy Infrastructure (Optional)
  # ============================================================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (github.event.inputs.deploy_infrastructure == 'true' || contains(github.event.head_commit.message, '[deploy-infra]'))
    
    # Required for OIDC
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-Infrastructure-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Validate CloudFormation templates
      run: |
        aws cloudformation validate-template --template-body file://infrastructure/main-infrastructure.yaml
        aws cloudformation validate-template --template-body file://infrastructure/networking.yaml
    
    - name: Deploy infrastructure
      run: |
        aws cloudformation deploy \
          --template-file infrastructure/main-infrastructure.yaml \
          --stack-name children-drawing-prod \
          --parameter-overrides \
            Environment=production \
            S3BucketPrefix=${{ secrets.S3_BUCKET_PREFIX || 'children-drawing' }} \
            ECRRepositoryURI=${{ secrets.ECR_REPOSITORY_URI || '' }} \
            DomainName=${{ secrets.DOMAIN_NAME || '' }} \
            CertificateArn=${{ secrets.CERTIFICATE_ARN || '' }} \
            EnableRoute53=${{ secrets.ENABLE_ROUTE53 || 'false' }} \
            CostAlertEmail=${{ secrets.COST_ALERT_EMAIL || '' }} \
          --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
          --region ${{ env.AWS_REGION }} \
          --tags Environment=production Project=ChildrenDrawingAnomalyDetection

  # ============================================================================
  # Deploy Application to ECS
  # ============================================================================
  deploy-application:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/main'
    
    # Required for OIDC
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-Deploy-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Download task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_CLUSTER }}-task \
          --query taskDefinition > task-definition.json
    
    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ needs.build-and-push.outputs.image-uri }}
    
    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
    
    - name: Verify deployment
      run: |
        # Wait for deployment to complete
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        
        # Get service status
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}'
    
    - name: Invalidate CloudFront cache
      run: |
        # Get CloudFront distribution ID from CloudFormation stack
        DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
          --stack-name children-drawing-prod \
          --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
          --output text)
        
        if [ ! -z "$DISTRIBUTION_ID" ]; then
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"
          echo "CloudFront cache invalidated for distribution: $DISTRIBUTION_ID"
        fi

  # ============================================================================
  # Health Check and Rollback
  # ============================================================================
  health-check:
    name: Health Check and Rollback
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: github.ref == 'refs/heads/main'
    
    # Required for OIDC
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-HealthCheck-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Get application URL
      id: get-url
      run: |
        APP_URL=$(aws cloudformation describe-stacks \
          --stack-name children-drawing-prod \
          --query 'Stacks[0].Outputs[?OutputKey==`ApplicationURL`].OutputValue' \
          --output text)
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT
    
    - name: Health check
      id: health-check
      run: |
        echo "Performing health check on: ${{ steps.get-url.outputs.app-url }}"
        
        # Wait for application to be ready
        sleep 60
        
        # Perform health check with retries
        for i in {1..5}; do
          if curl -f -s "${{ steps.get-url.outputs.app-url }}/health" > /dev/null; then
            echo "Health check passed on attempt $i"
            echo "health-status=success" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "Health check failed on attempt $i"
            sleep 30
          fi
        done
        
        echo "health-status=failed" >> $GITHUB_OUTPUT
        exit 1
    
    - name: Advanced health checks
      if: steps.health-check.outputs.health-status == 'success'
      run: |
        # Additional health checks for critical endpoints
        APP_URL="${{ steps.get-url.outputs.app-url }}"
        
        # Check API endpoints
        echo "Testing API endpoints..."
        curl -f -s "$APP_URL/api/v1/health" || echo "API health check failed"
        
        # Check static assets
        echo "Testing static assets..."
        curl -f -s "$APP_URL/static/" || echo "Static assets check failed"
        
        # Performance check - response time should be reasonable
        echo "Testing response time..."
        RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$APP_URL/health")
        echo "Response time: ${RESPONSE_TIME}s"
        
        # Fail if response time is too slow (> 10 seconds)
        if (( $(echo "$RESPONSE_TIME > 10.0" | bc -l) )); then
          echo "Response time too slow: ${RESPONSE_TIME}s"
          echo "health-status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Rollback on failure
      if: steps.health-check.outputs.health-status == 'failed'
      run: |
        echo "Health check failed, initiating rollback..."
        
        # Get previous task definition
        PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions \
          --family-prefix ${{ env.ECS_CLUSTER }}-task \
          --status ACTIVE \
          --sort DESC \
          --query 'taskDefinitionArns[1]' \
          --output text)
        
        if [ ! -z "$PREVIOUS_TASK_DEF" ] && [ "$PREVIOUS_TASK_DEF" != "None" ]; then
          echo "Rolling back to: $PREVIOUS_TASK_DEF"
          
          # Update service to use previous task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition $PREVIOUS_TASK_DEF
          
          # Wait for rollback to complete
          echo "Waiting for rollback to complete..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          
          # Verify rollback health
          echo "Verifying rollback health..."
          sleep 30
          
          APP_URL=$(aws cloudformation describe-stacks \
            --stack-name children-drawing-prod \
            --query 'Stacks[0].Outputs[?OutputKey==`ApplicationURL`].OutputValue' \
            --output text)
          
          # Test rolled back version
          for i in {1..3}; do
            if curl -f -s "$APP_URL/health" > /dev/null; then
              echo "Rollback health check passed on attempt $i"
              echo "Rollback completed successfully"
              break
            else
              echo "Rollback health check failed on attempt $i"
              sleep 15
            fi
          done
          
          echo "Rollback completed"
        else
          echo "No previous task definition found for rollback"
          echo "Manual intervention required"
        fi
        
        exit 1

  # ============================================================================
  # Deployment Monitoring and Alerting
  # ============================================================================
  monitor-deployment:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: [health-check]
    if: always() && github.ref == 'refs/heads/main'
    
    # Required for OIDC
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-Monitor-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check deployment metrics
      run: |
        # Get ECS service metrics
        aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Pending:pendingCount}'
        
        # Check CloudWatch metrics for errors
        END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S)
        START_TIME=$(date -u -d '10 minutes ago' +%Y-%m-%dT%H:%M:%S)
        
        echo "Checking error rates from $START_TIME to $END_TIME"
        
        # This would check application-specific metrics
        # aws cloudwatch get-metric-statistics \
        #   --namespace "AWS/ApplicationELB" \
        #   --metric-name "HTTPCode_Target_5XX_Count" \
        #   --start-time "$START_TIME" \
        #   --end-time "$END_TIME" \
        #   --period 300 \
        #   --statistics Sum
    
    - name: Create deployment summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment Status**: ${{ needs.health-check.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.health-check.result }}" == "success" ]; then
          echo "- **Result**: ✅ Deployment successful" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Result**: ❌ Deployment failed or rolled back" >> $GITHUB_STEP_SUMMARY
        fi

  # ============================================================================
  # Notification
  # ============================================================================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [deploy-application, health-check, monitor-deployment]
    if: always() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Determine deployment outcome
      id: outcome
      run: |
        if [ "${{ needs.health-check.result }}" == "success" ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "message=Deployment completed successfully" >> $GITHUB_OUTPUT
          echo "color=good" >> $GITHUB_OUTPUT
          echo "emoji=✅" >> $GITHUB_OUTPUT
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "message=Deployment failed or health check failed" >> $GITHUB_OUTPUT
          echo "color=danger" >> $GITHUB_OUTPUT
          echo "emoji=❌" >> $GITHUB_OUTPUT
        fi
    
    - name: Send Slack notification
      if: env.SLACK_WEBHOOK_URL != ''
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"attachments\": [{
              \"color\": \"${{ steps.outcome.outputs.color }}\",
              \"title\": \"${{ steps.outcome.outputs.emoji }} ${{ steps.outcome.outputs.status }}: Children's Drawing System Deployment\",
              \"text\": \"${{ steps.outcome.outputs.message }}\",
              \"fields\": [
                {\"title\": \"Commit\", \"value\": \"${{ github.sha }}\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"${{ github.ref_name }}\", \"short\": true},
                {\"title\": \"Author\", \"value\": \"${{ github.actor }}\", \"short\": true},
                {\"title\": \"Workflow\", \"value\": \"${{ github.run_id }}\", \"short\": true}
              ],
              \"actions\": [
                {
                  \"type\": \"button\",
                  \"text\": \"View Workflow\",
                  \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                }
              ]
            }]
          }" \
          $SLACK_WEBHOOK_URL
    
    - name: Send email notification
      if: env.NOTIFICATION_EMAIL != ''
      env:
        NOTIFICATION_EMAIL: ${{ secrets.NOTIFICATION_EMAIL }}
      run: |
        # This would integrate with AWS SES or another email service
        echo "Email notification would be sent to: $NOTIFICATION_EMAIL"
        echo "Status: ${{ steps.outcome.outputs.status }}"
        echo "Message: ${{ steps.outcome.outputs.message }}"
    
    - name: Update GitHub deployment status
      uses: actions/github-script@v7
      with:
        script: |
          const status = '${{ steps.outcome.outputs.status }}' === 'success' ? 'success' : 'failure';
          const description = '${{ steps.outcome.outputs.message }}';
          
          // Create deployment status
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: context.payload.deployment?.id || 0,
            state: status,
            description: description,
            environment: 'production'
          });
    
    - name: Create GitHub issue on failure
      if: steps.outcome.outputs.status == 'failure'
      uses: actions/github-script@v7
      with:
        script: |
          const title = `Deployment Failed: ${context.sha.substring(0, 7)}`;
          const body = `
          ## Deployment Failure Report
          
          **Commit**: ${context.sha}
          **Branch**: ${context.ref}
          **Author**: ${context.actor}
          **Workflow Run**: [${context.runId}](${context.payload.repository.html_url}/actions/runs/${context.runId})
          **Timestamp**: ${new Date().toISOString()}
          
          ### Details
          ${{ steps.outcome.outputs.message }}
          
          ### Next Steps
          - [ ] Investigate the failure cause
          - [ ] Fix the issue
          - [ ] Re-run the deployment
          - [ ] Verify the fix
          
          ### Logs
          Check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for detailed information.
          `;
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: title,
            body: body,
            labels: ['deployment-failure', 'bug', 'high-priority']
          });